"""
Escáner de vulnerabilidades SSL/TLS para el Proyecto Sócrates
Implementa detección de vulnerabilidades conocidas según documentación PDF
"""

import subprocess
import socket
import ssl
import struct
import requests
import re
from urllib.parse import urlparse
import logging

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Escáner de vulnerabilidades que implementa detección según PDF:
    - Heartbleed (CVE-2014-0160)
    - POODLE (CVE-2014-3566)
    - DROWN (CVE-2016-0800)
    - BEAST, CRIME, BREACH
    - Logjam y FREAK
    """

    def __init__(self):
        self.timeout = 10

    def scan_vulnerabilities(self, hostname, port=443):
        """
        Escaneo completo de vulnerabilidades SSL/TLS
        """
        vulnerabilities = []

        # Ejecutar todas las pruebas de vulnerabilidades
        vulnerability_tests = [
            self._test_heartbleed,
            self._test_poodle,
            self._test_drown,
            self._test_beast,
            self._test_crime,
            self._test_breach,
            self._test_logjam,
            self._test_freak,
            self._test_weak_ciphers,
            self._test_ssl_versions
        ]

        for test in vulnerability_tests:
            try:
                result = test(hostname, port)
                if result:
                    vulnerabilities.extend(result if isinstance(result, list) else [result])
            except Exception as e:
                logger.warning(f"Vulnerability test failed for {hostname}:{port}: {e}")

        return vulnerabilities

    def _test_heartbleed(self, hostname, port):
        """
        Test para Heartbleed (CVE-2014-0160)
        """
        try:
            # Implementar test de Heartbleed
            # Esta es una versión simplificada - en producción usar herramientas especializadas

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((hostname, port))

            # Enviar Client Hello con extensión Heartbeat
            hello = self._build_client_hello_with_heartbeat()
            sock.send(hello)

            # Leer respuesta del servidor
            response = sock.recv(4096)
            sock.close()

            # Verificar si el servidor soporta Heartbeat
            if b'\x00\x0f' in response:  # Heartbeat extension
                # Enviar Heartbeat Request malicioso
                return self._test_heartbleed_payload(hostname, port)

        except Exception as e:
            logger.debug(f"Heartbleed test failed: {e}")

        return None

    def _test_poodle(self, hostname, port):
        """
        Test para POODLE (CVE-2014-3566)
        """
        try:
            # Verificar si SSLv3 está habilitado
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)
            ssock.close()

            return {
                'name': 'POODLE',
                'severity': 'HIGH',
                'cve': 'CVE-2014-3566',
                'description': 'SSLv3 está habilitado, vulnerable a ataques POODLE',
                'recommendation': 'Deshabilitar SSLv3 en el servidor'
            }

        except ssl.SSLError:
            # SSLv3 no soportado, no vulnerable
            pass
        except Exception as e:
            logger.debug(f"POODLE test failed: {e}")

        return None

    def _test_drown(self, hostname, port):
        """
        Test para DROWN (CVE-2016-0800)
        """
        try:
            # Verificar si SSLv2 está habilitado
            # SSLv2 no está disponible en Python SSL, usar socket raw
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((hostname, port))

            # Enviar SSLv2 Client Hello
            sslv2_hello = self._build_sslv2_client_hello()
            sock.send(sslv2_hello)

            response = sock.recv(1024)
            sock.close()

            # Verificar si el servidor responde con SSLv2
            if len(response) > 0 and response[0:1] == b'\x16':
                return {
                    'name': 'DROWN',
                    'severity': 'CRITICAL',
                    'cve': 'CVE-2016-0800',
                    'description': 'SSLv2 está habilitado, vulnerable a ataques DROWN',
                    'recommendation': 'Deshabilitar SSLv2 completamente'
                }

        except Exception as e:
            logger.debug(f"DROWN test failed: {e}")

        return None

    def _test_beast(self, hostname, port):
        """
        Test para BEAST
        """
        try:
            # BEAST afecta TLS 1.0 con cifrados CBC
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)

            cipher = ssock.cipher()
            ssock.close()

            if cipher and 'CBC' in cipher[0]:
                return {
                    'name': 'BEAST',
                    'severity': 'MEDIUM',
                    'description': 'TLS 1.0 con cifrados CBC habilitado, vulnerable a BEAST',
                    'recommendation': 'Usar TLS 1.2+ o cifrados que no sean CBC'
                }

        except Exception as e:
            logger.debug(f"BEAST test failed: {e}")

        return None

    def _test_crime(self, hostname, port):
        """
        Test para CRIME
        """
        try:
            # CRIME afecta cuando TLS compression está habilitado
            # Intentar conectar y verificar compresión
            sock = socket.create_connection((hostname, port), timeout=self.timeout)

            # Enviar Client Hello con compresión habilitada
            hello_with_compression = self._build_client_hello_with_compression()
            sock.send(hello_with_compression)

            response = sock.recv(4096)
            sock.close()

            # Verificar si el servidor acepta compresión
            if self._check_compression_in_response(response):
                return {
                    'name': 'CRIME',
                    'severity': 'MEDIUM',
                    'description': 'Compresión TLS habilitada, vulnerable a CRIME',
                    'recommendation': 'Deshabilitar compresión TLS'
                }

        except Exception as e:
            logger.debug(f"CRIME test failed: {e}")

        return None

    def _test_breach(self, hostname, port):
        """
        Test para BREACH
        """
        try:
            # BREACH afecta compresión HTTP (gzip)
            url = f"https://{hostname}:{port}" if port != 443 else f"https://{hostname}"

            headers = {
                'Accept-Encoding': 'gzip, deflate',
                'User-Agent': 'Socrates-SSL-Scanner/1.0'
            }

            response = requests.get(url, headers=headers, timeout=self.timeout, verify=False)

            if response.headers.get('Content-Encoding', '').lower() in ['gzip', 'deflate']:
                return {
                    'name': 'BREACH',
                    'severity': 'MEDIUM',
                    'description': 'Compresión HTTP habilitada, potencialmente vulnerable a BREACH',
                    'recommendation': 'Considerar deshabilitar compresión HTTP para contenido sensible'
                }

        except Exception as e:
            logger.debug(f"BREACH test failed: {e}")

        return None

    def _test_logjam(self, hostname, port):
        """
        Test para Logjam
        """
        try:
            # Logjam afecta intercambio de claves Diffie-Hellman débil
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            context.set_ciphers('DHE:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA')

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)

            cipher = ssock.cipher()
            ssock.close()

            if cipher and 'DHE' in cipher[0]:
                # Verificar tamaño de parámetros DH (simplificado)
                return {
                    'name': 'Logjam',
                    'severity': 'MEDIUM',
                    'description': 'Intercambio de claves Diffie-Hellman detectado, verificar fortaleza',
                    'recommendation': 'Usar parámetros DH de al menos 2048 bits'
                }

        except Exception as e:
            logger.debug(f"Logjam test failed: {e}")

        return None

    def _test_freak(self, hostname, port):
        """
        Test para FREAK
        """
        try:
            # FREAK afecta cifrados de exportación RSA
            context = ssl.SSLContext(ssl.PROTOCOL_TLS)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            context.set_ciphers('EXPORT')

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)
            ssock.close()

            return {
                'name': 'FREAK',
                'severity': 'HIGH',
                'description': 'Cifrados de exportación RSA habilitados, vulnerable a FREAK',
                'recommendation': 'Deshabilitar todos los cifrados de exportación'
            }

        except Exception as e:
            logger.debug(f"FREAK test failed: {e}")

        return None

    def _test_weak_ciphers(self, hostname, port):
        """
        Test para cifrados débiles
        """
        vulnerabilities = []
        weak_ciphers = ['RC4', 'DES', '3DES', 'NULL', 'EXPORT', 'MD5']

        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)

            cipher = ssock.cipher()
            ssock.close()

            if cipher:
                cipher_name = cipher[0]
                for weak in weak_ciphers:
                    if weak in cipher_name:
                        vulnerabilities.append({
                            'name': f'Weak Cipher: {weak}',
                            'severity': 'MEDIUM',
                            'description': f'Cifrado débil detectado: {cipher_name}',
                            'recommendation': f'Deshabilitar cifrados que contengan {weak}'
                        })

        except Exception as e:
            logger.debug(f"Weak ciphers test failed: {e}")

        return vulnerabilities

    def _test_ssl_versions(self, hostname, port):
        """
        Test para versiones SSL/TLS inseguras
        """
        vulnerabilities = []

        # Test SSLv3 (ya cubierto en POODLE, pero agregar info general)
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)
            ssock.close()

            vulnerabilities.append({
                'name': 'SSLv3 Enabled',
                'severity': 'HIGH',
                'description': 'SSLv3 está habilitado y es inseguro',
                'recommendation': 'Deshabilitar SSLv3, usar TLS 1.2 o superior'
            })

        except:
            pass

        # Test TLS 1.0
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

            sock = socket.create_connection((hostname, port), timeout=self.timeout)
            ssock = context.wrap_socket(sock)
            ssock.close()

            vulnerabilities.append({
                'name': 'TLS 1.0 Enabled',
                'severity': 'LOW',
                'description': 'TLS 1.0 está habilitado y se considera obsoleto',
                'recommendation': 'Migrar a TLS 1.2 o superior'
            })

        except:
            pass

        return vulnerabilities

    # Métodos auxiliares para construcción de payloads

    def _build_client_hello_with_heartbeat(self):
        """Construir Client Hello con extensión Heartbeat"""
        # Implementación simplificada
        return b'\x16\x03\x02\x00\xdc\x01\x00\x00\xd8\x03\x02' + b'\x00' * 200

    def _build_sslv2_client_hello(self):
        """Construir SSLv2 Client Hello"""
        return b'\x80\x2e\x01\x00\x02\x00\x15\x00\x00\x00\x10\x01\x00\x80\x03\x00\x80\x07\x00\xc0'

    def _build_client_hello_with_compression(self):
        """Construir Client Hello con compresión"""
        return b'\x16\x03\x01\x00\x6d\x01\x00\x00\x69\x03\x03' + b'\x00' * 100

    def _check_compression_in_response(self, response):
        """Verificar si la respuesta indica compresión habilitada"""
        # Implementación simplificada
        return len(response) > 10 and b'\x01' in response[50:60]

    def _test_heartbleed_payload(self, hostname, port):
        """Test específico de payload Heartbleed"""
        try:
            # Esta sería la implementación del payload Heartbleed real
            # Por seguridad, esta es una versión simplificada
            return {
                'name': 'Heartbleed',
                'severity': 'CRITICAL',
                'cve': 'CVE-2014-0160',
                'description': 'Servidor potencialmente vulnerable a Heartbleed',
                'recommendation': 'Actualizar OpenSSL inmediatamente'
            }
        except:
            return None